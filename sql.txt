-- Database: Ecom

-- DROP DATABASE IF EXISTS "Ecom";

CREATE DATABASE "Ecom"
    WITH 
    OWNER = postgres
    ENCODING = 'UTF8'
    LC_COLLATE = 'English_India.1252'
    LC_CTYPE = 'English_India.1252'
    TABLESPACE = pg_default
    CONNECTION LIMIT = -1;

-- SCHEMA: dbo

-- DROP SCHEMA IF EXISTS dbo ;

CREATE SCHEMA IF NOT EXISTS dbo
    AUTHORIZATION postgres;

-- Table: dbo.orders

-- DROP TABLE IF EXISTS dbo.orders;

CREATE TABLE IF NOT EXISTS dbo.orders
(
    uid integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nric character varying(10) COLLATE pg_catalog."default",
    "Region" character varying(100) COLLATE pg_catalog."default",
    "Country" character varying(100) COLLATE pg_catalog."default",
    "Item Type" character varying(100) COLLATE pg_catalog."default",
    "Sales Channel" character varying(100) COLLATE pg_catalog."default",
    "Order Priority" character varying(100) COLLATE pg_catalog."default",
    "Order Date" date,
    "Order ID" integer,
    "Ship Date" date,
    "Units Sold" integer,
    "Unit Price" double precision,
    "Unit Cost" double precision,
    "Total Revenue" double precision,
    "Total Cost" double precision,
    "Total Profit" double precision
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS dbo.orders
    OWNER to postgres;

-- FUNCTION: dbo.generate_nric()

-- DROP FUNCTION IF EXISTS dbo.generate_nric();

CREATE OR REPLACE FUNCTION dbo.generate_nric(
	)
    RETURNS character varying
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE nric character varying(10);
  chars text[] := '{S,T,F,G}';
  result text := '';
  i integer := 0;
BEGIN

	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	result := result ||  (SELECT array_to_string(ARRAY(SELECT chr((48 + round(random() * 9)) :: integer) FROM generate_series(1,7)), ''));
	
	IF(((random() *10) :: integer)%2 = 0) THEN --append capital letter
		result := result ||  (SELECT array_to_string(ARRAY(SELECT chr((65 + round(random() * 25)) :: integer) FROM generate_series(1,1)), ''));
	ELSE  -- append small letter
		result := result ||  (SELECT array_to_string(ARRAY(SELECT chr((97  + round(random() * 25)) :: integer) FROM generate_series(1,1)), ''));
	END IF;
	
-- 	while (select count(*) from dbo.orders o where o.nric = result) > 0 loop
-- 		result := (select * from  dbo.generate_nric());
-- 	end loop;
  return result;
	
END;
$BODY$;

ALTER FUNCTION dbo.generate_nric()
    OWNER TO postgres;


-- FUNCTION: dbo.update_nric()

-- DROP FUNCTION IF EXISTS dbo.update_nric();

CREATE OR REPLACE FUNCTION dbo.update_nric(
	)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
	update dbo.orders set nric = null where nric in (
		select nric from  dbo.orders group by nric having count(*) > 1
	);
		
	update dbo.orders set nric =dbo.generate_nric() where nric is null;
	
	while((select count(*) from (select nric from  dbo.orders group by nric having count(*) > 1)t ) > 0) loop
		return (select * From dbo.update_nric());
	end loop;
	return  True;
	
END;
$BODY$;

ALTER FUNCTION dbo.update_nric()
    OWNER TO postgres;


-- FUNCTION: dbo.save_orders(json)

-- DROP FUNCTION IF EXISTS dbo.save_orders(json);

CREATE OR REPLACE FUNCTION dbo.save_orders(
	req_jsontext json)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE flag boolean;
BEGIN
	SET DATESTYLE TO 'SQL, MDY';

	INSERT INTO dbo.orders (nric, "Region", "Country", "Item Type", "Sales Channel", "Order Priority", "Order Date", "Order ID", "Ship Date", "Units Sold", "Unit Price", "Unit Cost", "Total Revenue", "Total Cost", "Total Profit")
	SELECT  dbo.generate_nric(), "Region", "Country", "Item Type", "Sales Channel", "Order Priority", "Order Date", "Order ID", "Ship Date", "Units Sold", "Unit Price", "Unit Cost", "Total Revenue", "Total Cost", "Total Profit"
	FROM json_populate_recordset(null::dbo.orders, req_jsonText );
-- 	VALUES(req_orderid,req_name );
	flag := (select * from dbo.update_nric());
	RETURN True;
END;
$BODY$;

ALTER FUNCTION dbo.save_orders(json)
    OWNER TO postgres;


-- FUNCTION: dbo.get_orders(integer, integer)

-- DROP FUNCTION IF EXISTS dbo.get_orders(integer, integer);

CREATE OR REPLACE FUNCTION dbo.get_orders(
	pagenumber integer,
	pagesize integer)
    RETURNS TABLE(nric character varying, region character varying, country character varying, itemtype character varying, saleschannel character varying, orderpriority character varying, orderdate character varying, orderid integer, shipdate character varying, unitssold integer, unitprice double precision, unitcost double precision, totalrevenue double precision, totalcost double precision, totalprofit double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	SET DATESTYLE TO 'SQL, MDY';

	RETURN QUERY (
		SELECT o.nric, "Region", "Country", "Item Type", "Sales Channel", 
		"Order Priority", "Order Date" :: character varying, "Order ID", 
		"Ship Date" :: character varying, 
		"Units Sold", "Unit Price", "Unit Cost", "Total Revenue",
		"Total Cost", "Total Profit"
		FROM dbo.orders o WHERE o.nric is not null
		ORDER BY uid 
		DESC OFFSET (pagenumber-1)*pagesize 
		LIMIT pagesize
	);
	
END;
$BODY$;

ALTER FUNCTION dbo.get_orders(integer, integer)
    OWNER TO postgres;
